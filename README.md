![Image](/Resource/beosimttnk_httpss.mj.runLaJriHwd1GY_move_fire_darkness_sky_--_f6426a9d-c0b2-4305-97e1-3a4e519c3337_1.gif)
---

<aside>

# “짧지만 밀도 있는 전략 경험”

https://www.youtube.com/watch?v=f5Qd2yA9-lQ

</aside>

<aside>

## 게임 개요

> **장르**: 2D 로그라이크 전략 게임
**레퍼런스 게임**: 다키스트 던전
**플레이 타임**: 약 30분 내외 (1회 플레이 기준)
> 

---

미지의 숲 곳곳을 개척하며, 수상한 조짐이 있는 최종 목표 지점(마을)에 도달하는 것이 목표입니다.

플레이어는 짧은 시간 동안 지속적으로 전략적인 판단을 내리며 게임을 이어나갑니다.

---

</aside>

---

<aside>

## “주어진 한 턴, 당신의 선택이 생존을 가른다.”

**Darkest Dungeon**을 **오마주** 한 게임으로, 숲을 개척해 나아가는 용병들의 이야기이며, 

**짧지만 깊은 플레이로 끊임없는 전략적 선택**을 목표로 만든 게임입니다.

### 🧭 모험을 하며 발생하는 전략적인 선택

![Image](/Resource/broshue.gif)
- 전투 - 용병 - 상점 - 함정 - 보물 -


**매번 달라지는 이벤트** 속에서 어디로 갈지, 어떤 자원을 소비할지 **끊임없는 판단**을 요구합니다.


### **⚔️ 차별화된 성장 ‘무기 숙련도’ 시스템**

무기마다 **경험**이 축적되어 스킬과 
전투 방식이 달라집니다.

같은 용병이라도 어떤 무기를 다뤘는지에 따라
**전투 스타일과 전략**이 완전히 달라집니다.

![Image](/Resource/Weapon_Tutorial_01.gif)

### 🔁 반복 속에서 달라지는 탐험

**완전히 랜덤으로 생성되는 맵**과 **로드아웃 선택**으로 매 판 새로운 조합과 전략이 만들어집니다.
이전의 경험은 다음 탐험에 영향을 미치며, 반복 플레이 속에서 더 큰 성장과 성취가 쌓입니다.

![Image](/Resource/map.gif)

![Image](/Resource/image.png)

![Image](/Resource/image_3.png)

### **향후에는…**

**심볼 시스템**과 **확장 이벤트**를 추가하여, 인게임의 전략적 깊이와 아웃게임의 성장 요소 모두를 충실히 채워나갈 예정입니다.

> **👇아래에는 사용 기술, 유저 테스트 등이 정리되어 있습니다! 궁금하다면 계속 읽어주세요!**
> 
</aside>

## 목차

---

- 게임 기능 소개
- 게임 흐름 & 설계
- 사용된 기술 스택
- 구현 기술 & 개발 기법
- 개인 트러블 슈팅
- 사용자 개선 사항
- 프로젝트 결과 및 성과
- 팀원 구성

## 게임 기능 소개

---

- 타이틀
    
    
   ![Image](/Resource/image_2.png)
    
    메인 타이틀 화면
    
   ![Image](/Resource/image_3.png)
  
    게임 시작 클릭 시 등장하는 로드아웃
    
    ![Image](/Resource/image_4.png)
  
    스테이지 선택
    
    - 메인 타이틀 화면
        - 게임 시작
        - 로드아웃
            
            
            ![Image](/Resource/image_14.png)
          
            로드아웃 상점
            
            ![Image](/Resource/image_5.png)
            
            로드아웃 업적
            
            - 로드아웃 업적 : 업적 클리어 → 해금 포인트 획득 가능
            - 로드아웃 상점 : 포인트로 로드아웃 요소 해금 가능
            - 게임 시작 클릭 시 등장하는 로드아웃 : 해금된 로드아웃 요소들 → 일부 선택/장착 가능
        - 설정
        - 게임 종료
    - 스테이지 → 현재 스테이지 클리어 시 다음 스테이지 오픈
- 튜토리얼
    
    ![Image](/Resource/image_21.png)
    
    튜토리얼 이미지
    
    - 최초 게임시작 시 튜토리얼 진입
        - 이후 설정에서 ‘튜토리얼 다시하기’로 플레이 가능
- 스테이지 진행
    - 방/통로 설명
        - 방 : 전투/ 보물 상자/ 용병 고용/ 상점 방 중 랜덤으로 하나가 등장함.
        - 통로 : 방과 방을 잇는 길 (함정, 보물상자 등의 이벤트 존재함)
        
        ![Image](/Resource/image_22.png)
        
    - 방에서는 플레이어 이동 불가능
    - 빨간색 테두리가 있는 ‘방’을 클릭 → 통로로 이동 (플레이어 이동 가능)
        
        ![Image](/Resource/image_23.gif)
        
        ‘방’ 클릭 → 통로 이동
        
- 전투 (전투 방식)
    - 턴 진행
        
        ![Image](/Resource/image_24.gif)
        
        턴 주고 받기
        
        - 턴 순서
            1. 속도가 빠른 캐릭터부터 턴 진행
            2. 속도가 같다면 플레이어 우선
            3. 같은 진영 내에서 동일 속도 → 랜덤 추첨
            
            > 턴 진행 예시
            > 
            - 플레이어 속도 : 5, 5, 7, 3
            - 적 속도 : 5, 4, 3, 3
            
            턴 진행 순서 : 3번 플레이어(속도 7) → (1번 or 2번 플레이어, 속도 5 중 랜덤) → 1번 적(속도 5) → 2번 적(속도 4) → 4번 플레이어(속도 3) - (3번 or 4번 적, 속도 3 중 랜덤)
            
        - 턴
            - 전투는 턴 순서에 따라 각 캐릭터가 행동함
            - 수행 가능한 행동
                - 스킬 사용
                - 이동 (위치 바꾸기)
                - 아이템 사용
                - 행동 넘기기
            - 스킬 사용 시 → 속도에 비례해 추가 턴을 얻을 확률 존재
            - 캐릭터 사망 시 → 뒤 캐릭터가 순서를 당겨 자리를 채움
    - 스킬
        
        
        ![Image](/Resource/image_25.png)
        
        스킬 버튼을 클릭했을 때 (타겟팅 범위 붉은색 표시)
        
        ![Image](/Resource/image_26.png)
      
        적을 클릭해서 스킬 사용했을 때
        
        - 스킬 버튼 클릭 → 스킬 범위(붉은색 표시)의 적을 클릭하면 스킬 사용됨
- 용병
    - 무기 숙련도
        
       ![Image](/Resource/image_27.gif)
       
        무기 숙련도 이미지
        
        - 장비 장착 시 ‘숙련도’ 시스템이 열림
        - 숙련도 상승 : 스킬 사용, 적 처치, 승리, 새로운 맵 방문 등
        - 숙련도를 다 채우면 무기 스킬 & 외형 업그레이드
    - 용병 고용
        
        ![Image](/Resource/image_28.gif)
      
        - ‘용병 고용 방’에서 용병 고용/해고 가능
        - 용병마다 다른 특성을 가짐
- 아이템
    - 획득 / 사용처
        - 전투 승리 or 보물 상자 오픈 시 재화/아이템 획득 가능
        - 상점에서 재화로 구매/판매 가능
        
       ![Image](/Resource/image_29.png)
      
        보상 UI
        
        ![Image](/Resource/image_30.png)
        
        상점 이미지
        
    - 인벤토리
        
        ![Image](/Resource/image_31.png)
        
        플레이어 정보 창                                                                            인벤토리 창
        
        - 조작 : Shift + 좌클릭으로 아이템 버리기, 좌클릭으로 사용
        - 아이템 사용
            - 전투중 → 전투 지원 아이템만 사용 가능
            - 탐험중 → 탐험 지원 아이템만 사용 가능
        - 드래그 앤 드롭
            - 인벤토리 ↔ 장비창 간 장착/해제
            - 슬롯 간 위치 변경 및 동일 아이템 병합 가능
            - 보상 아이템 일괄 수령 및 선택 수령 지원
    - 툴팁 (정보창)
        - 마우스 커서를 원하는 스킬/아이템 위에 올리면 툴팁 표시
        
        ![Image](/Resource/image_32.png)
      
        마우스 커서를 ‘물약’ 위에 올린 상태
        
        ![Image](/Resource/image_33.png)
      
        마우스 커서를 ‘2번째 스킬’ 위에 올린 상태
        

## 게임 흐름 & 설계

---

<aside>

[Ctrl + 휠을 통해 움직일 수 있습니다.](https://embed.figma.com/board/c09hbpX1j576kd4BucOk1z/%ED%99%94%EB%A9%B4-%EC%84%A4%EA%B3%84?node-id=0-1&p=f&t=ygUCtU9RnmGy1fbo-0&embed-host=notion&footer=false&theme=system)

Ctrl + 휠을 통해 움직일 수 있습니다.

</aside>

- 클래스 다이어그램
    
    <aside>
    
    ### 클래스 다이어그램
    
    ![Image](/Resource/image_41.png)
    
    - 스킬
    - 플레이어 & 적
    </aside>
    

## 사용된 기술 스택

---

### IDE

![Image](/Resource/image_42.png)

VS 2022

![Image](/Resource/image_43.png)

Rider

### 개발 엔진

![2022.03.62f2](https://images.sftcdn.net/images/t_app-icon-m/p/afefb922-96d3-11e6-a7f1-00163ec9f5fa/3752006191/unity-icon.jpg)

2022.03.62f2

### 버전 관리/협업 툴

![Image](/Resource/image_44.png)

github

![Image](/Resource/image_45.png)

Discord

### 일정 관리

![Image](/Resource/image_46.png)

엑셀

![Image](/Resource/image_47.png)

노션

## 구현 기술 & 개발 기법

---

<aside>

## ⚙️ 핵심 기술

<aside>

### **절차적 맵(Room) 생성 시스템**

---

![Image](/Resource/image_48.gif)

- 런타임 시 랜덤 시드 기반 → 맵 자동 생성
- 방(Room)과 복도(Corridor) → 그래프 구조로 연결
- 매번 다른 맵 제공 → **재플레이 가치 극대화**
- **플로우차트**
    
    ![Image](/Resource/image_49.png)
    
    맵 생성 플로우차트
    
    - 방을 무작위로 생성하되, 첫 번째 방은 항상 “시작 방”으로, 남은 하나의 방은 “보스 방”으로 고정됨
    - “이전 단계에서 만들어진 방”이라는 List를 각 단계의 마지막에 초기화하고 이번 단계에서 만들어진 방을 넣음으로써 다음 단계로 나아갈 준비
    
    ![Image](/Resource/image_50.png)
    
    방 생성 플로우차트
    
    방 생성에서 가장 중요한 것은 “정말로 생성할 수 있는 방인지”에 대한 유효성 검사와, 부모 방과 새로운 방을 연결하는 것이었음
    
</aside>

<aside>

### **가중치 기반 AI 의사결정 시스템**

---

- 가중치 코드
    
    ```csharp
    public static class RandomizeUtility
    {
        public static int TryGetRandomPlayerIndexByWeight(List<float> weights) // 플레이어별 가중치 리스트 받아옴
        {
            float total = 0f;
            int playerIndex = -1;
    
            foreach (var weight in weights) // 가중치 합 계산
                total += weight;
    
            float rand = UnityEngine.Random.value * total; // 랜덤값 설정
    
            int i = 0;
            foreach (var weight in weights)
            {
                rand -= weight; // 지정된 랜덤값에서 가중치를 반복해서 빼줌
    
                if (rand <= 0f) // 음수가 될 경우
                {
                    playerIndex = i; // playerIndex 뽑음
                    break;
                }
                i++;
            }
            return playerIndex;
        }
    }
    ```
    
    - 플레이어별 가중치 리스트를 받아, 가중치에 비례한 확률로 playerIndex를 반환하는 유틸 함수
    - 동작 순서
        1. 전체 가중치의 합을 구하고, `랜덤값 = 난수 * 가중치 합` 계산
        2. 각 가중치를 순서대로 빼가며 누적
        3. 랜덤값이 0 이하가 되는 순간, 해당 인덱스를 선택
            
            → 가중치가 높을수록 선택 확률이 증가
            
- **상태 기반 가중치 조정**
    - HP 등 전투 상황에 따라, 각 스킬의 선택 확률(가중치) 동적 변경
- **확률 기반 타겟팅**
    - 플레이어 개별 체력·위치 정보를 반영 → 공격 대상 확률적으로 선택
- **전략(Strategy) 패턴 적용**
    - 스킬 행동을 하나의 규칙(전략)처럼 만듦 → AI가 유연하게 다양한 스킬을 선택·실행
</aside>

<aside>

### **버프/디버프 상태 효과 시스템**

---

- 지속 시간(Trun 기반)으로 상태 효과 관리
- 효과 중첩(Stack) 및 자동 해제 기능 지원
- 턴마다 상태 자동 갱신 → 관리 부담 최소화
</aside>

<aside>

### **스킬 선택 (옵저버 패턴 + 전략 패턴)**

---

- 구현 방법
    1. **플레이어 턴 시작** → InGamePlayerUI에 스킬 버튼 4개 표시
    2. **스킬 버튼 클릭** (SelectSkillButton) → InGameUIManager가 이벤트 발송
    3. **대상 버튼 활성화** → 스킬 타입에 따라 적/아군 버튼 활성화
    4. **대상 선택** (SelectEnemyButton / SelectCharacterButton) → 스킬 실행
    5. **효과 적용** → DamageSkill / HealSkill / BuffSkill
    6. **턴 종료** → BattleManager.EndTurn()
- **스킬 선택 (옵저버 패턴)**
    
    ```csharp
    // InGameUIManager가 Subject
    private Action<Skill> buttonSkillActiveAction;
    
    // 모든 대상 버튼이 Observer로 구독
    inGameUIManager.AddSkillButtonAction(ActiveSkillButtonAction, DeActiveSkillButtonAction);
    
    // 스킬 선택 시 모든 버튼에 알림
    buttonSkillActiveAction?.Invoke(skill);
    ```
    
    - 옵저버 패턴 사용으로 스킬 사용이 아닌 아이템, 위치 변경 등 유연한 변경이 가능
- **스킬 적용 (전략 패턴)**
    
    ```csharp
    public abstract class SkillEffect 
    {
        public abstract void ActiveEffect(BaseEntity actionEntity, BaseEntity targetEntity);
    }
    
    /*
    - DamageSkill: 공격력 기반 데미지
    - HealSkill: 공격력 기반 + 고정값 회복
    - BuffSkill: 지속 시간 있는 상태 효과
    */
    ```
    
    - 새로운 스킬 추가 시 기존 로직 수정 없이 클래스 추가만으로 확장 가능
</aside>

<aside>

### 커스텀 에디터(전투 테스트 툴)

---

![Image](/Resource/Test.gif)

**커스텀 에디터를 통해 전투 테스트 툴을 개발함**

- 구현 방법
    
    ```csharp
    		private int[] _playerIDs = new int[4];
        private int[] _enemyIDs = new int[4];
    
        private (int, int, int, int, float, float)[] _playerStatInfo = new (int, int, int, int, float, float)[4]; //health, attack, defense, speed, evasion, critical
        private (int, int, int, int, float, float)[] _enemyStatInfo = new (int, int, int, int, float, float)[4];
    ```
    
    - 플레이어블 캐릭터와 적의 ID를 4개씩, 최대 8개의 ID를 할당
    - 6개씩 총 48개의 스탯 데이터를 튜플과 배열로 구조화
    - GUI 프로그래밍으로 직관적인 입력 환경을 구축
    - 까다로운 데이터 유효성 검증 로직을 통해 휴먼 에러를 최소화하고 안정적인 테스트 환경을 구축
</aside>

<aside>

### 인벤토리/장비창

---

![Image](/Resource/image_51.gif)

**드래그 앤 드롭 기반 인벤토리/장비창 시스템을 구현했습니다.**

- 구현 방법
    
    ```csharp
    public interface ItemDragDropManager 
        InGameItem[] GetItems { get; }
    
        void UpdateUI();
        void OnDropSwap(int index1, int index2);
        void OnDrop();
        bool OnDrop(ItemDrop drop, IDraggingObject draggingObject);
        public void RemoveItem(InGameItem item);
    }
    ```
    
    - 인벤토리에는 총 10개의 슬롯이 있으며, 각 슬롯에 인덱스 번호를 지정해 주었습니다.
    - 장비창에는 총 3개의 슬롯이 있으며 각 슬롯에는 저장할 수 있는 아이템 타입을 지정해 주었습니다.
    - 각 아이템은 인벤토리 슬롯에 저장되며 외부 아이템 창 (보상 및 장비창) 과의 상호작용이 가능하게 설계하였습니다.
    - 드래그 앤 드롭 시스템은 각 창마다 비슷한 로직을 공유하기 때문에 인터페이스를 사용하였습니다.
    - 인벤토리, 장비, 보상창과의 원활한 상호작용을 위해 enum 을 이용해 설계하였습니다.
    
    ```csharp
    public enum DragOrigin
    {
        Inventory,
        Equipment,
        Reward,
    }
    ```
    
</aside>

## ⚙️ 디자인 패턴

- 싱글톤(Singleton) : AudioManager, DataManager, GameManager등 핵심 시스템의 전역 접근 관리
- 옵저버(Observer) : UI 간 이벤트 브로드캐스트
- 전략(Strategy) : 스킬 효과를 유연하게 확장
- 상태(State) : 턴 기반 전투 흐름 관리 시 사용
- 팩토리(Factory) : 맵 타입별 제너레이터 선택 → 생성 로직 유연하게 함
- 템플릿 메서드(Template) : BaseRoom의 공통 흐름 정의 → 하위 클래스(BattleRoom, ShopRoom, TreasureRoom등)가 세부 단계 구현

## ⚙️ 데이터 관리

- **UGS (Unity Gaming Services)** : Google Sheets **↔** JSON 연동으로 데이터 관리
    - 코드 수정 없이 게임 밸런스 조정 가능
- **JSON 저장 방식** : 로컬 세이브 데이터 관리 (업적, 설정, 진행도 등)
- **퍼널 분석(Funnel Analytics)** : 사용자 행동 데이터 시각화 → 개선 방향 도출

## ⚙️ 기타

- 오디오 믹서(Audio Mixer) 기반의 Master/BGM/SFX 볼륨 조절
</aside>

## 개인 트러블 슈팅

---

<aside>

## 이찬희 / 이찬희 짱만세

---

- **절차적 맵 생성 트러블 슈팅**
    
    > **문제**
    > 
    
    ![Image](/Resource/image_52.gif)
    
    - 방이 사방으로 가로막혀 더 이상 방을 생성하지 못한다면 더 이상 방 생성을 하지 못한다.
    - 방을 만들 수 있는 유효성 체크를 그 방과 복도를 통해 직접적으로 연결된 방만 체크한다.
    
    > **이유**
    > 
    1. 첫 번째 문제는 맵 생성 규칙을 "가장 최근 방에서만 다음 방을 확장"하도록 설계했기에, 극악의 확률(약 0.6%)로  현재 방이 사방으로 막힐 경우 맵 생성이 **그대로 중단되는 치명적인 문제**가 발생했습니다.
    2. 두 번째 문제는 각 방이 **오로지 직접 연결된 인접 방의 정보**만 알고 있도록 설계되었습니다. 이로 인해 맵 전체의 유효성이나 연결성을 검사할 때, 연결된 방을 따라가며 중복 검사를 해야 하는 **비효율적인 그래프 탐색**이 우려되었습니다.
    
    > **해결방법**
    > 
    
    전 이 두 문제를 방의 위치에 대한 정보를 “시작방으로부터 이 방이 뻗어나간 경로”를 string형식으로 주어 해결했습니다.
    
    이를테면, 시작 방의 위의 방이라면 U, 아래 방이라면 D, 왼쪽 방이라면 L, 오른쪽 방이라면 R이라는 string값을 갖게 됩니다. 따라서 위의 그림의 마지막 방의 경우엔 URRDDLU라는 string 값을 가지게 됩니다.
    
    > **결과**
    > 
    
    이 해결방법은 두 가지 문제를 전부 해결했습니다.
    
    - 방이 사방으로 가로막혀 더 이상 방을 생성하지 못하는 문제가 발생될 시, 방의 위치를 나타내는 string에서 하나를 지우고, 그 해당 string을 가지고 있는 방으로 가면 “가장 최근에 생성된 방”에서 바로 직전에 생성된 방을 간단히 알 수 있게 되어, 해당 방으로 돌아가 방 생성을 이어나갈 수 있게 되었습니다!
        
        
        예를 들어, 위 그림에선 URRDDL로 돌아가 방 생성을 이어나갈 수 있게 됩니다.
        
    - 또한 이렇게 만들어진 string을 (int, int) 튜플로 변환해 각 방이 숫자로 표현된 좌표를 가진 것과 같게 합니다. U은 (0, +1), D은 (0, -1), L은 (-1, 0), R은 (+1, 0)을 더하게됩니다.
    
    예를 들어, 마지막 방인 URRDDLU는 (+1, 0)값을, 즉, 시작 방에서 바로 오른쪽에 있는 방이라는 좌표를 가지게 되는데요. 이는 시작 방과 마지막 방이 직접적으로 연결되어있지 않음에도 시작 방의 바로 오른쪽에 방이 생성되었다는 정보를 나타냅니다!
</aside>

<aside>

## 이명은  / 개발

---

- **오브젝트에 아웃라인이 적용되지 않음 (버튼에서는 정상 작동)**
    - 원인
        - Unity의 기본 Outline 컴포넌트는 Graphic에만 적용 가능
        - 즉, Sprite Renderer나 Mesh Renderer를 사용하는 일반 오브젝트에는 작동하지 않음
    - 시도
        1. 최상위 오브젝트를 UI(캔버스)로 변경
            1. 범위 감지를 위해 오브젝트가 월드 상에 존재해야 함 → UI는 위치가 달라 실패
        2. Canvas를 월드 좌표로 변경
            1. 범위 감지는 가능
            2. 단, 오브젝트 클릭 시 UI(함정 해제, 보상UI)의 위치가 달라지거나, 화면에서 잘림
        3. 오브젝트 + Material로 코드 구현 시도
            1. 코드 구현 → Material 추가 → 스프라이트의 Material을 SpriteOutline로 변경
            2. 여러 시도에도 불구하고, 아웃라인 적용 실패
    - 해결
        - 아웃라인 흉내용 이미지를 원본 Sprite 뒤에 겹치고 색만 변경
        - 위의 작업은 버튼 Canvas에서 처리 → 아웃라인과 UI 모두 정상 동작
    
    - 배운 점
        - 아웃라인 → UI에서만 사용 가능
        - 원래 오브젝트에 아웃라인 넣으려면 관련된 쉐이더 작업을 해야 함
    
    > **다시 구현한다면?**
    > 
    > - 함정 해제/보상 UI를 프리팹화
    > - 최상위 오브젝트를 UI(월드 좌표)로 두고, 동적 로딩으로 보상 UI만 생성
    > - 범위 감지 + UI 위치 고정 + 아웃라인 모두 적용 가능할 것으로 보임
    > - 혹은 쉐이더로 해결해봐도 좋을 것 같음
</aside>

<aside>

## 고태웅 / 개발

---

- **WebGL 환경에서 제한**
    
    > **문제 1**
    > 
    - Unity Analytic를 초기화 할 때 Task를 사용하여 async/await로 대기를 주었지만 작동X
    
    > **이유**
    > 
    - WebGL은 웹 환경에 맞게 래핑된 API이므로 JavaScript로 빌드가 되었습니다. 그런데 JavaScript는 단일 스레드 환경이기 때문에 Task, Thread, async/await 로 병렬 작업을 만드는 방식은 사용할 수 없었습니다.
    - Task는 내부적으로 스레드 풀을 사용합니다. 실행 시점에 OS가 컨텍스트 스위칭을 수행해서 멀티 스레드였습니다.
    
    > **해결방법**
    > 
    - UniTask는 메인 스레드 내부에서 상태 머신으로 스위칭되기 때문에 단일 스레드 환경에서 작동이됨 그래서 Task로 작동하는 부분을 UniTask로 변경하였습니다.
    
    > **문제 2**
    > 
    - Firebase Realtime Database사용 할 때 SDK, Rest API 직접적으로 사용X
    
    > **이유**
    > 
    - Firebase에서는 WebGL에서의 직접 접근을 ****공식적으로 지원하지 않습니다.
    
    > **해결방법**
    > 
    - IL2CPP 우회 이 버전 만들 예정
    - 클라이언트 → 백엔드 → Firebase로 우회하여 사용하는 방법을 생각하였습니다.
    - AWS에 백엔드 C++ 서버를 구축하여 CURL로 Firebase RestAPI를 호출하도록 개발하였습니다.
</aside>

<aside>

## 박인성 / 개발

---

- **아이템 드래그 실패 시 원래 슬롯으로 복귀하지 않는 문제**
    - 상황
        - 드래그 불가능한 위치에 아이템을 드롭하면, 아이템이 원래 슬롯으로 돌아가야 하나 실제로는 드롭된 채로 남고, 한 슬롯에 여러 아이템이 중복 저장되는 현상 발생.
    - 원인 추청
        - CanDrop() 함수에서 항상 true 를 반환하여 드롭 검증이 무시되는 것으로 의심.
    - 시도
        1. CanDrop() 함수 호출 여부 확인 → Debug.Log() 를 통해 함수가 정상적으로 호출됨을 확인.
        2. 반환값 검증 →  드롭 불가능한 경우 false 를 정상 반환하는 것으로 확인.
            1. 결론: CanDrop() 로직에는 문제 없음.
    - 해결
        - 실제 문제: 드롭 실패 시 아이템을 원래 위치로 되돌리는 복귀 로직 미구현.
        - 구현 내용:
            - 드래그 시작 시 현재 슬롯 인덱스를 originalPosition 변수에 저장.
            - 드롭 실패 (CanDrop() == false) 시, 아이템 아이콘을 originalPosition 으로 이동.
            - UpdateUI() 호출을 통해 인벤토리 UI 즉시 갱신.
    - 결과
        - 드래그 실패 시 아이템이 정상적으로 원래 슬롯으로 복귀하면, 중복 저장 문제 해결.
- **스킬 툴팁 갱신 문제**
    - 상황
        - 플레이어 스킬 사용 또는 턴 변경 후, 스킬 버튼 툴팁이 이전 캐릭터 정보를 유지하거나 비활성화 스킬에서 갱신되지 않음.
    - 원인 추청
        - 플레이어 턴 종료 후, UpdateTooltip() 이 호출되지 않는 것으로 의심.
    - 시도
        - UpdateTooltip() 함수 동작 확인 → 정상 작동함을 확인.
        - 실제 문제: OnPointerEnter 인터페이스에만 의존 → 마우스가 버튼 위에 있는 상태에서 플레이어 교체 시 툴팁 재설정되지 않음.
    - 해결
        - 기존에 OnPointerEnter 인터페이스에만 의존해서 툴팁을 팝업시켰는데 그럴 경우, 마우스가 스킬창 위에 있는 상태에서 플레이어가 교체되거나 턴 종료되면 툴팁이 그대로 남아있게 되는걸 확인함.
            - isHovered 플래그를 추가해서 항상 마우스 상태를 추적시켜 주는 로직을 만들어서 SetButton() 함수에서 스킬 버튼이 업데이트 될 때마다 isHovered 변수를 이용해 툴팁도 같이 Update 해주는 방식으로 설계.
        - isHovered 플래그 추가 → 마우스 hover 상태 추적.
        - OnPointerEnter/Exit 에서 플래그 설정 및 UpdateTooltip() 호출.
        - SetButton() 함수 내 모든 스킬 갱신 로직에서 if(isHovered == true)  일 경우 툴팁 업데이트.
        - 비활성화 스킬 툴팁 표시를 위해 UpdateTooltip() 조건에서 isActive 검사 제거.
    - 결과
        - 플레이어 변경/스킬 사용 후 툴팁 정상 갱신.
        - 비활성화 스킬에도 툴팁 표시.
</aside>

<aside>

## 권진석 / 개발

---

- **상점 아이템이 안바뀌는 문제**
    - 상황
    여러 상점에서 각각 확률에따라 다른 아이템이 나와야하는데 닫아도 처음 생성된 아이템이 다른 상점에서도 똑같이나왔습니다
    - 원인
    상점을 켜고 꺼주고만 있어서 리셋시켜주는 함수가 필요해보였습니다
    - 해결
    한번 이용한 상점은 다시 이용 할 수 없기때문에 완전히 삭제하는 방법으로 새로 생성해주는 방법으로 해결했습니다
    - 결과
    닫기 버튼을 누르면 다시 상점이 열리지않고 새로운 상점방으로 들어가면 새로운 물품으로 생성됨 기획자 의도대로 해결했습니다
    
- **튜토리얼시 안멈추는 버그**
    - 상황
    델타타임으로 멈춰줬는데 특정상황에서 안멈추는 문제입니다
    - 원인
    다른코드 함정이라던지 이벤트에서 델타타임을 겹쳐서 쓰고있어서 생긴 문제 입니다
    - 해결
    게임매니저에서 새로운 함수로  이동(A와 D)키를 눌러도 움직이지않게 변경했습니다
    - 결과
    다른 시간을 멈추는 이벤트들과 겹쳐도 이동자체를 못하기때문에 튜토리얼 팝업창을 닫기전까지 움직여지지 않습니다
</aside>

<aside>

## 박훈 / 기획, 팀장

---

- **적의 행동 가중치 설계**
    
    **배경**
    
    적의 행동을 완전 무작위로 설정했을 때 전략적 긴장감은 생기지만,
    
    플레이어가 피로감을 느끼거나 전투의 인과성이 약해지는 문제가 발생했다.
    
    **문제**
    
    적 행동을 결정하는 규칙이 없으면 전략적 예측이 불가능하고,
    
    반대로 규칙이 지나치게 고정되면 전투가 패턴화되어 긴장감이 떨어진다.
    
    **해결 방안 탐색**
    
    행동 선택 방식을 세 가지로 구분해 비교하였다.
    
    **규칙 기반 우선 순위 선택, 가중치 기반 우선 순위 선택, 가중치 기반 확률 선택**
    
    이후 각 방식의 장단점을 분석하고, 최종적으로 ‘**가중치 기반 확률 선택**’을 채택했다.
    
    ---
    
    - 규칙 기반 우선순위 선택
        
        <aside>
        
        역할군·상황 규칙을 쌓아 **행동/타겟 우선 순위**를 부여.
        
        ---
        
        **✅ 장점**
        
        1. **예측 가능**하고 일관성 있음
        2. **명시적 행동 연출**이 가능 (탱커 → 도발, 힐러 → 회복 등)
        
        **❌ 단점**
        
        1. 패턴이 빠르게 **고착화**되어 플레이어가 AI를 쉽게 파악함
        2. 규칙이 많아질수록 **복잡도와 유지보수 비용 증가**
        
        ---
        
        **적합한 상황**
        
        - 보스전, 튜토리얼 등 **예측 가능한 행동이 중요한 구간**
        </aside>
        
    - 가중치 기반 우선순위 선택
        
        <aside>
        
        행동·타겟에 **가중치(score)**를 주고, 높은 순서대로 선택.
        
        ---
        
        **✅ 장점** 
        
        1. **유연한 제어** 가능 (수치 조정으로 경향 변경 용이)
        2. **복합 조건 판단**에 유리 (HP, 거리, 버프 등 수치화 가능)
        
        **❌ 단점** 
        
        1. **무작위성 부족**으로 반복 플레이 시 패턴화될 수 있음
        2. 일부 조건이 과도하게 영향을 미쳐 **비정상적 점수 폭주 위험** 가능
        
        ---
        
        **적합한 상황**
        
        - 일반 전투, **전략적 판단이 필요한 상황**
        - 다양한 조건을 고려해 합리적 행동을 유도할 때
        </aside>
        
    - 가중치 기반 확률 선택
        
        <aside>
        
        가중치를 **확률 분포**로 변환해 추첨.
        
        ---
        
        **✅ 장점**
        
        1. **행동 다양성 확보** → 매 턴 다른 선택 가능
        2. **예측 불가능성**이 증가해 플레이어의 **전략적 긴장감** 상승
        
        **❌ 단점**
        
        1. 확률에 따라 **비일관적 결과** 발생 가능 (예: 힐러가 힐 안 함)
        2. **세밀한 제어 어려움**, 디버깅 시 재현성 낮음
        
        ---
        
        **적합한 상황**
        
        - 로그라이크나 **랜덤성을 강조하는 전투 시스템**
        - 반복 플레이의 신선함을 유지해야 할 때
        </aside>
        
    
    **무작위 대상 정하기**
    
    ---
    
    무작위로 정한 행동의 대상도 완전 무작위로 설정하면 인과성이 약해져 전략성이 떨어진다.
    
    이를 보완하기 위해 **어그로 수치를 활용해 대상 선택에 가중치**를 부여했다,
    이때, 글로벌(모든 적 공유)과 로컬(개별 적) 방식들을 비교·검토했다.
    
    | **구분** | **설명** | **장점** | **단점** |
    | --- | --- | --- | --- |
    | 글로벌 어그로 | 모든 적이 동일한 어그로 수치 참조 | **예측 용이**, 난이도 하락 | 전략 다양성 ↓ |
    | 로컬 어그로 | 각 적이 캐릭터별 개별 어그로 백터 가짐 | **역할군·빌드 등 반응 다양성** | 계산랑 ↑ |
</aside>

<aside>

## 김민혁 / 기획

---

- **AI를 이용한 기획서 작성에 대한 고찰**
    
    > **문제**
    > 
    - 기획서 작성이 잘 되지 않고 **기한 압박과 초조함 때문에 AI에게 기획**을 대신 맡기려 한 것
    - 내가 **생각하는 과정을 생략하고 AI에 의존하는 형태**가 되어 버림
    
    > **이유**
    > 
    - 피로감과 불안으로 인해 **속도에만 집중**
    - 스스로의 판단보다 **AI의 즉각적인 피드백과 답변에만 의존하려는 심리**가 작동함
    - 내 스스로가 **사고를 해야하는 기본적인 규칙**을 잊어버림
    - 기획의 본질인 **개요, 기획의도의 구체화**를 건너 뛰어버림
    
    > **해결 방법**
    > 
    - AI를 도구로만 사용한다는 원칙을 재정립함
    → AI는 생각을 돕는 도구이자 도우미다. 나 대신 생각하는 존재가 아니다.
    - 기획을 다시 세분화 하여 재시작하기
    1. 스스로 초안을 작성하기
    2. 그 뒤 내 생각을 좀더 상세하게 적어보기
    3. 부족한게 느껴지면 AI에게 조언을 받는정도로만 사용하기
    - 기획서 작성 시 기본 틀을 매번 점검하기
    개요 → 기획의도 → 상세기획 구조
    - 필요 시 AI사용 가이드라인을 스스로 규정해 넘지 말아야 할 선을 인지하기
    
    > **결과**
    > 
    - AI의 의존도가 줄고, 기획의 논리와 방향성을 스스로 잡는 능력이 향상됨
    - 기획서의 구성과 표현이 더 명확해지고 일관성이 생김
    - 내가 만든 기획이라는 확신과 책임감을 다시 가지게 됨
    - AI를 효율적인 보조 도구로 활용하는 균형 잡힌 습관 확립
    
</aside>

| 이름 | 직책 | 역할 | 블로그 | 깃허브 | 연락처 |
| --- | --- | --- | --- | --- | --- |
| 박훈 | 팀장 | 기획 | https://hello-new-world.tistory.com/ | https://github.com/Hu-ni | hundl5789@gmail.com |
| 김민혁 | 팀원 | 기획 | https://anvilking.tistory.com/ | https://github.com/anvilking1500 | vhffltmgur@naver.com |
| 이찬희 | 개발 팀장 | 개발 | https://chanylee.tistory.com/ | https://github.com/ChanyTheAwesome | Chanyblackbear@gmail.com |
| 권진석 | 팀원 | 개발 | https://velog.io/@rnjswlstjr1/posts |  | rnjswlstjr1@naver.com |
| 고태웅 | 팀원 | 개발 | [개발 Hub](https://www.notion.so/Hub-af5131c7863e435db64cd226734245c6?pvs=21) | https://github.com/taewooo513 | taewooo0513@gmail.com |
| 박인성 | 팀원 | 개발 | https://velog.io/@caramellatte1122/posts | https://github.com/Caramellatte1122 | sleepwithoutadream@gmail.com |
| 이명은 | 팀원 | 개발 | https://blog.naver.com/ralralra1dlq | https://github.com/myeoungeun/ | melee0110@naver.com |
